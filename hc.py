# -*- coding: utf-8 -*-
"""hc.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Hj9NV12Ux4WOtsmJloa2pSp044mQJd1p
"""

#HC
import random
import math

# Biblioteca para geração de graficos para facilitar visualizão
import matplotlib.pyplot as plt

# Parametros
MAX_NUMERO_DE_ITERACOES = 50000

cidades = cidades_inicial_usando_referencia()

def executar_hill_climbing():

  # É gerada uma solução inicial aleatoria
  solucao_atual = gerar_solucao_aleatoria()

  # É calculado o fitness da solução incial
  melhor_fitness = fitness(solucao_atual)

  # É definido um criterio de parada
  numero_de_iteracoes = MAX_NUMERO_DE_ITERACOES

  # print('Fitness Inicial: ', "%.3f" % melhor_fitness)

  # --- Função para demonstração visual utilizando matplotlib ---
  # gerar_grafico(cidades, solucao_atual)

  # --- Inicio da execução do algoritimo ---

  # Criterio de parada 1
  # Seguro pois independe do que acontecer no algoritimo o codigo ira finalizar 
  # sua execução
  for i in range(0, numero_de_iteracoes):

  # Criterio de parada 2 
  # Pode causar problemas pois caso o valor de fitness desejado nao seja atingido
  # (caso o algoritimo fique preso num ponto de otimo local por exemplo) o 
  # algoritimo pode ficar rodando indeterminadamente
  # while True:
  # if melhor_fitness < 7000:
  #   break

    # Uma nova solução é gerada
    nova_solucao = mudar_solucao(solucao_atual)

    # A nova solução é comparada com a anterior
    if fitness(nova_solucao) < fitness(solucao_atual):

      # Caso ela seja melhor a anterior é substituida pela nova
      solucao_atual.clear()
      for j in range(0, NUMERO_DE_CIDADES):
        solucao_atual.append(nova_solucao[j])
      # e o melhor fitness é atualizado
      melhor_fitness = fitness(solucao_atual)

  # --- Função para demonstração visual utilizando matplotlib ---
  # gerar_grafico(cidades, solucao_atual)

  return melhor_fitness